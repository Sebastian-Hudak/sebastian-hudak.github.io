<script>
    const header = document.getElementById("header");
    window.addEventListener("scroll", () => {
      if (window.scrollY > 5) header.classList.add("on-scroll");
      else header.classList.remove("on-scroll");
    });
  </script>

  <script>
    (function () {
      const buttons = document.querySelectorAll(".projects__filter");
      const cards = document.querySelectorAll(".project-card");

      function setActive(btn) {
        buttons.forEach(b => b.classList.remove("is-active"));
        btn.classList.add("is-active");
      }

      function filterCards(tag) {
        cards.forEach(card => {
          const tags = (card.getAttribute("data-tags") || "")
            .split(",")
            .map(t => t.trim())
            .filter(Boolean);

          const show = tag === "all" || tags.includes(tag);
          card.classList.toggle("is-hidden", !show);
        });
      }

      buttons.forEach(btn => {
        btn.addEventListener("click", () => {
          const tag = btn.getAttribute("data-filter");
          setActive(btn);
          filterCards(tag);
        });
      });
    })();
  </script>


  <script>
  (function () {
    const burger = document.querySelector(".burger");
    const nav = document.querySelector(".nav");
    if (!burger || !nav) return;

    burger.addEventListener("click", () => {
      const open = nav.classList.toggle("is-open");
      burger.classList.toggle("is-active", open);
      burger.setAttribute("aria-expanded", open ? "true" : "false");
    });

    // Close menu when a link is clicked (mobile)
    nav.querySelectorAll("a").forEach(a => {
      a.addEventListener("click", () => {
        nav.classList.remove("is-open");
        burger.classList.remove("is-active");
        burger.setAttribute("aria-expanded", "false");
      });
    });
  })();
</script>


<script>
  (function () {
    const items = document.querySelectorAll(".reveal");

    if (!items.length) return;

    const obs = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            entry.target.classList.add("is-visible");
            obs.unobserve(entry.target); // animate only once
          }
        });
      },
      {
        threshold: 0.15,
        rootMargin: "0px 0px -10% 0px"
      }
    );

    items.forEach((el) => obs.observe(el));
  })();

  document.addEventListener("DOMContentLoaded", () => {
  const cards = document.querySelectorAll(".education-card");

  const io = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        // add when it becomes visible enough
        if (entry.isIntersecting) entry.target.classList.add("is-inview");
        else entry.target.classList.remove("is-inview"); // optional
      });
    },
    {
      root: null,
      threshold: 0.55,              // ~55% visible triggers it
      rootMargin: "0px 0px -10% 0px" // trigger slightly before center
    }
  );

  cards.forEach((c) => io.observe(c));
});
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const flips = document.querySelectorAll(".flip");

  flips.forEach((flip) => {
    flip.addEventListener("click", (e) => {
      e.stopPropagation();
      flip.classList.toggle("is-flipped");
    });
  });

  document.addEventListener("click", () => {
    flips.forEach((f) => f.classList.remove("is-flipped"));
  });

  // optional: allow Esc to close when focused (desktop)
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") flips.forEach((f) => f.classList.remove("is-flipped"));
  });
});
</script>

<script>
document.addEventListener("DOMContentLoaded", () => {
  const grid = document.querySelector("#projectsGrid");
  const dotsWrap = document.querySelector(".projects__dots");
  if (!grid || !dotsWrap) return;

  const allCards = Array.from(grid.querySelectorAll(".project-card"));

  const isVisible = (el) => {
    // works for .is-hidden { display:none } and other hiding methods
    return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
  };

  let io = null;

  function buildDots() {
    // only cards currently visible after filtering
    const cards = allCards.filter(isVisible);

    // hide dots completely if 0/1 slides
    dotsWrap.innerHTML = "";
    dotsWrap.style.display = (cards.length <= 1) ? "none" : "flex";

    // disconnect old observer
    if (io) io.disconnect();
    if (!cards.length) return;

    // create dots
    const dots = cards.map((_, i) => {
      const b = document.createElement("button");
      b.className = "projects__dot";
      b.type = "button";
      b.setAttribute("aria-label", `Go to project ${i + 1}`);
      b.addEventListener("click", () => {
        cards[i].scrollIntoView({ behavior: "smooth", inline: "start", block: "nearest" });
      });
      dotsWrap.appendChild(b);
      return b;
    });

    const setActive = (idx) => {
      dots.forEach((d, i) => d.classList.toggle("is-active", i === idx));
    };

    // observe visible cards to update dot
    io = new IntersectionObserver((entries) => {
      entries.forEach((e) => {
        if (e.isIntersecting) {
          const idx = cards.indexOf(e.target);
          if (idx !== -1) setActive(idx);
        }
      });
    }, { root: grid, threshold: 0.6 });

    cards.forEach(c => io.observe(c));

    // set active dot
setActive(0);

// Only auto-scroll the horizontal carousel on MOBILE,
// and only if the Projects section is already near the viewport.
const isMobileCarousel = window.matchMedia("(max-width: 600px)").matches;
const projSection = grid.closest(".projects");
const nearProjects = projSection && projSection.getBoundingClientRect().top < window.innerHeight * 0.6;

if (isMobileCarousel && nearProjects) {
  cards[0].scrollIntoView({ behavior: "auto", inline: "center", block: "nearest" });
}
  }

  // initial build
  buildDots();

  // Rebuild dots when filtering changes cards visibility
  // If your filter buttons toggle .is-hidden, this catches it.
  const mo = new MutationObserver(() => buildDots());
  mo.observe(grid, { attributes: true, subtree: true, attributeFilter: ["class", "style"] });

  // Also rebuild after clicking filter buttons (instant feedback)
  document.querySelectorAll(".projects__filter").forEach(btn => {
    btn.addEventListener("click", () => {
      // wait a tick for your existing filter JS to apply classes
      requestAnimationFrame(buildDots);
    });
  });
});

document.addEventListener("DOMContentLoaded", () => {
  const nav = document.getElementById("site-nav");
  if (!nav) return;

  const links = Array.from(nav.querySelectorAll("a.nav__link"));

  const currentPath = window.location.pathname.replace(/\/$/, "");
  const isIndex =
    currentPath === "" ||
    currentPath === "/" ||
    currentPath.endsWith("/index.html");

  const getHashId = (a) => {
    try {
      const url = new URL(a.getAttribute("href"), window.location.origin);
      return url.hash ? url.hash.slice(1) : null;
    } catch {
      const href = a.getAttribute("href") || "";
      const i = href.indexOf("#");
      return i >= 0 ? href.slice(i + 1) : null;
    }
  };

  // pass null to clear
  const setActive = (id) => {
    links.forEach((a) => {
      const linkId = getHashId(a);
      a.classList.toggle("is-active", Boolean(id) && linkId === id);
    });
  };

  // Highlight current PAGE link (e.g. /contact.html)
  const normalized = (p) => p.replace(/\/$/, "");
  links.forEach((a) => {
    const href = a.getAttribute("href") || "";
    if (href.includes("#")) return;
    try {
      const url = new URL(href, window.location.origin);
      if (normalized(url.pathname) === normalized(window.location.pathname)) {
        a.classList.add("is-active");
      }
    } catch {}
  });

  // Only run scroll-spy on index page
  if (!isIndex) return;

  const headerH = parseFloat(
    getComputedStyle(document.documentElement).getPropertyValue("--header-h")
  );
  const headerOffset = Number.isFinite(headerH) ? Math.round(headerH) : 80;

  // Build section items from hash links
  const items = links
    .map((a) => {
      const id = getHashId(a);
      const section = id ? document.getElementById(id) : null;
      return section ? { a, section, id } : null;
    })
    .filter(Boolean);

  if (!items.length) {
    console.warn("[scrollspy] No matching section IDs found for nav links.");
    return;
  }

  // TOP sentinel: clears active when hero/top is in view
  const topEl = document.getElementById("top"); // you have <section class="hero" id="top">
  if (topEl) {
    const topIO = new IntersectionObserver(
      (entries) => {
        const e = entries[0];
        if (e && e.isIntersecting) setActive(null);
      },
      {
        // Trigger "top" when you're near the start of the page
        rootMargin: `${-headerOffset}px 0px -75% 0px`,
        threshold: 0.15,
      }
    );
    topIO.observe(topEl);
  }

  // Initial highlight from hash; otherwise none
  if (window.location.hash) {
    const id = window.location.hash.slice(1);
    if (document.getElementById(id)) setActive(id);
    else setActive(null);
  } else {
    setActive(null);
  }

  const io = new IntersectionObserver(
    (entries) => {
      const visible = entries
        .filter((e) => e.isIntersecting)
        .sort((a, b) => b.intersectionRatio - a.intersectionRatio)[0];

      if (visible) setActive(visible.target.id);
      // If nothing is intersecting and weâ€™re above the first section, clear:
      else {
        const firstSectionTop = items[0].section.offsetTop;
        if (window.scrollY < firstSectionTop - headerOffset - 10) {
          setActive(null);
        }
      }
    },
    {
      rootMargin: `-${headerOffset}px 0px -55% 0px`,
      threshold: [0.15, 0.25, 0.4, 0.6],
    }
  );

  items.forEach(({ section }) => io.observe(section));
});
</script>

